package com.dragon.warIII.certificate;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.security.InvalidKeyException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PublicKey;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;

import org.apache.log4j.Logger;

import com.dragon.warIII.base64.Base64Util;
import com.dragon.warIII.rsa.RSAUtil;

/**
 * @description 功能描述: 证书加密工具类
 * @author 作 者: L.D
 * @createdate 建立日期：2016-9-7
 * @projectname 项目名称: Java_001_EncryptionAndDecryption
 * @packageclass 包及类名: com.dragon.warIII.certificate  CertificateUtil.java
 */
public class CertificateUtil {
	
	private static Logger logger = Logger.getLogger(CertificateUtil.class);
	
	private static String CERTIFICATE_PATH = null;
	
	static {
		CERTIFICATE_PATH = Thread.currentThread().getContextClassLoader()
				.getResource("certificate/201698.crt").getPath();
		System.out.println("CERTIFICATE_PATH=" + CERTIFICATE_PATH);
	}
	
	/**
	 * <p>1.加密</p>
	 */
	public static String encode(String source) {
		 try {
			//1.加载证书
			//证书格式为X509
			CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
			//2.读取证书文件的输入流
			InputStream certin = new FileInputStream(CERTIFICATE_PATH);
			Certificate certificate = certificateFactory.generateCertificate(certin);
			//3.从证书中得到公钥
			PublicKey publicKey = certificate.getPublicKey();
			
			logger.info("publicKey=" + publicKey);
			logger.info("公钥：" + RSAUtil.getKeyString(publicKey));
			logger.info("公钥长度：" + RSAUtil.getKeyString(publicKey).length());
			
			//4.加密
			Cipher cipher = Cipher.getInstance("RSA");
			cipher.init(Cipher.ENCRYPT_MODE, publicKey);
			byte[] cipherByte = cipher.doFinal(source.getBytes(StandardCharsets.UTF_8));
			
			String encodeSource = Base64Util.encode(cipherByte);
			
			logger.info("encodeSource=" + encodeSource);
			
			return encodeSource;
		} catch (CertificateException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (NoSuchAlgorithmException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (NoSuchPaddingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (InvalidKeyException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IllegalBlockSizeException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (BadPaddingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		 return null;
	}
}
